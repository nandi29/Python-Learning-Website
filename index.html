<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>RA1811028010037</title>
	</head>

	<body style="background-color:papayawhip;">
	<style>
		 body{ 
	font: 75% georgia, sans-serif;
	line-height: 1.88889;
	color: #555753; 
	background: #fff url(http://csszengarden.com/001/blossoms.jpg) no-repeat bottom right; 
	margin: 0; 
	padding: 0;
	}
p { 
	margin-top: 0; 
	text-align: justify;
	}
h3 { 
	font: italic normal 1.4em georgia, sans-serif;
	letter-spacing: 1px; 
	margin-bottom: 0; 
	color: #7D775C;
	}
a:link { 
	font-weight: bold; 
	text-decoration: none; 
	color: #B7A5DF;
	}
a:visited { 
	font-weight: bold; 
	text-decoration: none; 
	color: #D4CDDC;
	}
a:hover, a:focus, a:active { 
	text-decoration: underline; 
	color: #9685BA;
	}
	</style>

	<div>
		<img src="image.png" alt="HTML Letters" width="1400" height="218" /> 
	</div>

		<div>
<h3>BY - NANDINI CHOURASIA(RA1811028010037)</h3>
		</div>
		<div>
<h2>PYTHON </h2>
<p>Python is an interpreted, high-level, general-purpose programming language. Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. Python is often described as a "batteries included" language due to its comprehensive standard library.reference-</p>
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python programming wiki</a>

<h1 style="text-align:center;">PROGRAMMING PARADIGMS </h1>
<p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.

Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p>
<a href="https://en.wikipedia.org/wiki/Programming_paradigm">Programming Paradigms wiki</a>
		</div>
	<div>
		<h4>15 <mark>Types</mark> of paradigm:
		</h4>
	</div>
	<div>
<ul>
	                                                  <li>
	                                                       <h4> Structured programming </h4>
						</li>
	<p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.
		It emerged in the late 1950s with the appearance of the ALGOL 58 and ALGOL 60 programming languages,with the latter including support for block structures.</p>
	<p>Structured programming is most frequently used with <mark>deviations</mark> that allow for clearer programs-</p>
	<p>1.Exceptional Handling.</p>
	<p>2.Early Exit.</p>
	<p>3.Multiple Entry.</p>
	<p>4.State Machines.</p>
	<p>
	
The <mark>languages</mark> that support Structured programming approach are:</p>

<p>C,C++,Java,C#,etc.</p>
<p> <mark>ADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH   are:</p>
<p>1.Easier to read and understand</p>
<p>2.User Friendly</p>
<p>3.Easier to Maintain</p>
<p>4.Mainly problem based instead of being machine based</p>
<p>5.Development is easier as it requires less effort and time</p>
<p>6.Easier to Debug</p>
<p>7.Machine-Independent, mostly.</p>
<p> <mark>DISADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH  are:</p>
<p>Since it is Machine-Independent, So it takes time to convert into machine code.</p>
<p>The converted machine code is not the same as for assembly language.</p>
<p>The program depends upon changeable factors like data-types. Therefore it needs to be updated with the need on the go.</p>
<p>Usually the development in this approach takes longer time as it is language-dependent. Whereas in the case of assembly language, the development takes lesser time as it is fixed for the machine.</p>
		<p>for reference-
		</p>
	<a href="https://en.wikipedia.org/wiki/Structured_programming" class="design-name" target="_blank">Structural Programming Paradigm</a> 
                                                                    <li>
									    <h4> Procedural Programming </h4>	
							</li>
	<p>Procedural programming is a programming paradigm, derived from structured programming,[citation needed] based on the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself.</p>
	<p>Computer processors provide hardware support for procedural programming through a stack register and instructions for calling procedures and returning from them. Hardware support for other types of programming is possible, but no attempt was commercially successful (for example Lisp machines or Java processors).</p>
	<p>Some important <mark>FEATURES</mark> are:</p>
	<p>1.Global Variable</p>
	<p>2.Local Variable</p>
	<p>3.Pre-Defined Functions</p>
	<p>4.Parameter Passing</p>
	<p> <mark>ADVANTAGES</mark> OF PROCEDURAL PROGRAMMING   are:</p>
<p>1.Procedural Programming is excellent for general-purpose programming</p>
<p>2.The coded simplicity along with ease of implementation of compilers and interpreters</p>
<p>3.A large variety of books and online course material available on tested algorithms, making it easier to learn along the way</p>
<p>4.The source code is portable, therefore, it can be used to target a different CPU as well</p>
<p>5.The code can be reused in different parts of the program, without the need to copy it.</p>
	<p>6.Through Procedural Programming technique, the memory requirement also slashes</p>
<p>7.The program flow can be tracked easily</p>
	<p> <mark>DISADVANTAGES</mark> OF PROCEDURAL PROGRAMMING</p>
<p>1.The program code is harder to write when Procedural Programming is employed</p>
<p>2.The Procedural code is often not reusable, which may pose the need to recreate the code if is needed to use in another application</p>
<p>3.Difficult to relate with real-world objects</p>
<p>4.The importance is given to the operation rather than the data, which might pose issues in some data-sensitive cases</p>
<p>5.The data is exposed to the whole program, making it not so much security friendly</p>
		<p>for reference-
	</p>          									
						<a href="https://en.wikipedia.org/wiki/Procedural_programming" class="design-name" target="_blank">Procedural Programming Paradigm</a>
										<li>
											<h4> Object Oriented Programming </h4>
					</li>
<p>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields known as attributes or properties, and code, in the form of procedures known as methods</p>
<p>Object-oriented <mark>languages</mark> include Java, C++, C#, Python, PHP, JavaScript, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Common Lisp, MATLAB, and Smalltalk.</p>
<p><mark>Objects and classes </mark>
<p>Languages that support object-oriented programming (OOP) typically use inheritance for code reuse and extensibility in the form of either classes or prototypes. Those that use classes support two main concepts:</p>

<p>Classes – the definitions for the data format and available procedures for a given type or class of object; may also contain data and procedures (known as class methods) themselves, i.e. classes contain the data members and member functions</p>
<p>Objects – instances of classes.Objects sometimes correspond to things found in the real world.</p>
<p>Objects are accessed somewhat like variables with complex internal structure, and in many languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. They provide a layer of abstraction which can be used to separate internal from external code. External code can use an object by calling a specific instance method with a certain set of input parameters, read an instance variable, or write to an instance variable. Objects are created by calling a special type of method in the class known as a<mark> constructor</mark>. A program may create many instances of the same class as it runs, which operate independently. This is an easy way for the same procedures to be used on different sets of data.
</p>	
	<p><mark>KEY FEATURES OF OBJECT ORIENTED PROGRAMMING</mark></p>
	<p><mark>1.ENCAPSULATION</mark>: In normal terms, Encapsulation is defined as wrapping up of data and information under a single unit. In Object-Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.</p>
	<p><mark>2.POLYMORPHISM</mark>: The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.</p>
	<p><mark>3.INHERITANCE</mark>: The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object-Oriented Programming.</p>

<p>1.Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.</p>
<p>2.Super Class:The class whose properties are inherited by sub class is called Base Class or Super class.</p>
<p>3.Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.</p>
	<p>for reference-
	</p>          

	<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" class="design-name" target="_blank">Object Oriented Programming Paradigm</a>					<li>
	<h4>Event Driven Programming Paradigm</p>
					</li>
<p>In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).</p>

<p>In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.</p>
	<p>Most existing <mark>GUI development tools and architectures</mark> rely on event-driven programming.The Java AWT framework processes all UI changes on a single thread, called the Event dispatching thread. </p>
	<p>Features include</p>
	<p><mark>Event Handlers</mark>:</p>
	<p>The first step in developing an event-driven program is to write a series of subroutines, or methods, called event-handler routines. These routines handle the events to which the main program will respond. For example, a single left-button mouse-click on a command button in a GUI program may trigger a routine that will open another window, save data to a database or exit the application. Many modern-day programming environments provide the programmer with event templates, allowing the programmer to focus on writing the event code.</p>

<p>The second step is to bind event handlers to events so that the correct function is called when the event takes place. Graphical editors combine the first two steps: double-click on a button, and the editor creates an (empty) event handler associated with the user clicking the button and opens a text window so you can edit the event handler.</p>

<p>The third step in developing an event-driven program is to write the main loop. This is a function that checks for the occurrence of events, and then calls the matching event handler to process it. Most event-driven programming environments already provide this main loop, so it need not be specifically provided by the application programmer. RPG, an early programming language from IBM, whose 1960s design concept was similar to event-driven programming discussed above, provided a built-in main I/O loop (known as the "program cycle") where the calculations responded in accordance to 'indicators' (flags) that were set earlier in the cycle.</p>
	<p><mark>Exception Handlers</mark>:In PL/I, even though a program itself may not be predominantly event-driven, certain abnormal events such as a hardware error, overflow or "program checks" may occur that possibly prevent further processing. Exception handlers may be provided by "ON statements" in (unseen) callers to provide cleaning routines to clean up afterwards before termination, or to perform recovery operations and return to the interrupted procedure.</p>
	<p>for reference-
	</p>
	<a href="https://en.wikipedia.org/wiki/Event-driven_programming" class="design-name" target="_blank">Event Driven Programming Paradigm</a> 
	    <li>
		<h4>Declarative Programming Paradigm</h4>				
					</li>	
<p>Declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.</p>
<p>Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives(the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.</p>
<p>Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.</p>
<p>Common <mark>Declarative languages include</mark> those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.</p>
<p>Some important points:</p>
<p>1.Declarative programming is a programming paradigm that <mark>expresses the logic of a computation without describing its control flow.</mark>
<p>2.This paradigm often considers programs as theories of a formal logic, and computations as deductions in that logic space.</p>
<p>3.Declarative programming is often defined as any style of programming that is not imperative.</p>
<p>4.Common declarative languages include those of <mark>database query languages (SQL)</mark>, <mark>logic programming</mark>, <mark>functional programming</mark>, etc.</p>
<p>5.A program that describes what computation should be performed and not how to compute it. Non-imperative, non-procedural.
Any programming language that lacks side effects(example: a function might modify a global variable or static variable, modify one of its arguments, raise an exception,etc).</p>
<p>6.A language with a clear correspondence to mathematical logic.</p>
<p>Declarative Programming Paradigm:</p>
<p>A program that describes what computation should be performed and not how to compute it .</p>
<p>Any programming language that lacks side effects (or more specifically, is referentially transparent).</p>
<p>A language with a clear correspondence to mathematical logic</p>
<p>Here, the term side effect was mentioned.</p>
<p>A function or expression is said to have a side effect if, in addition to returning a value, it also modifies some state or has an observable interaction with calling functions or the outside world. For example, a function might modify a global variable or static variable, modify one of its arguments, raise an exception, write data to a display or file, read data, etc.</p>
<p>Examples of declarative languages are HTML, XML, CSS, JSON and SQL, and there are more</p>

<p><mark>SQL Elements</mark>:</p>
<p>SQL is the standard language used to communicate with a relational database.</p>
<p>It can be used to retrieve data from a database using a query but it can also be used to create, manage, destroy as well as modify their structure and contents.</p>

<p>The language is subdivided into several language elements, including:</p>
<p>1.Clauses</p>
<p>2.Expressions</p>
<p>3.Predicates</p>
<p>4.Queries</p>
<p>5.Statements</p>
	<p>for reference-
	</p>
	
	<a href="https://en.wikipedia.org/wiki/Declarative_programming" class="design-name">Declarative Programming Paradigm</a> 
	                                                                       <li>
						 <h4>Imperative Programming Paradigm</h4>
					</li>
<p>The imperative programming paradigm assumes that the computer can maintain through environments of variables any changes in a computation process. Computations are performed through a guided sequence of steps, in which these variables are referred to or changed. The order of the steps is crucial, because a given step will have different consequences depending on the current values of variables when the step is executed.</p>
<p><mark>Imperative Languages</mark>:<p>
<p>Popular programming languages are imperative more often than they are any other paradigm studies in this course. There are two reasons for such popularity:</p>

<p>1.the imperative paradigm most closely resembles the actual machine itself, so the programmer is much closer to the machine</p>
<p>2.because of such closeness, the imperative paradigm was the only one efficient enough for widespread use until recently</p>

<p><mark>Advantages</mark>:</p>
<p>1.efficient</p>
<p>2.close to the machine</p>
<p>3.popular</p>
<p>4.familiar</p>
<p><mark>Disadvantages</mark>:</p>
<p>1.The semantics of a program can be complex to understand or prove, because of referential transparency does not hold(due to side effects)</p>
<p>2.Side effects also make debugging harder</p>
<p>3.Abstration is more limitted than with some paradigms</4>
<p>4.Order is crucial, which doesn't always suit itself to problems.</p>
	<p>for reference-
	</p>	
	<a href="https://en.wikipedia.org/wiki/Imperative_programming" class="design-name" target="_blank">Imperative Programming Paradigm</a>
	                                                                       <li>
										    <h4>Parallel Programming Paradigm</h4>   
					</li>
<p>Parallel programming model is an abstraction of parallel computer architecture, with which it is convenient to express algorithms and their composition in programs. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently the compiled programs can execute.The implementation of a parallel programming model can take the form of a library invoked from a sequential language, as an extension to an existing language, or as an entirely new language.</p>
<p>Consensus around a particular programming model is important because it leads to different parallel computers being built with support for the model, thereby facilitating portability of software. In this sense, programming models are referred to as bridging between hardware and software.</p>

<p>A system is said to be parallel if it can support two or more actions executing simultaneously i.e., <mark>multiple actions are simultaneously executed in parallel systems</mark>.</p>
<p>The evolution of parallel processing, even if slow, gave rise to a considerable variety of programming paradigms.</p>
<mark>Parallelism Types:</mark>
<p>1.Explicit Parallelism</p>
<p>2.Implicit Parallelism</p>

<p><mark>Explicit parallelism</mark>:</p>
<p>Explicit Parallelism is characterized by the presence of explicit constructs in the programming language, aimed at describing (to a certain degree of detail) the way in which the parallel computation will take place.</p>
<p>A wide range of solutions exists within this framework. One extreme is represented by the ``ancient'' use of basic, low level mechanisms to deal with parallelism--like fork/join primitives, semaphores, etc--eventually added to existing programming languages. Although this allows the highest degree of flexibility (any form of parallel control can be implemented in terms of the basic low level primitives gif), it leaves the additional layer of complexity completely on the shoulders of the programmer, making his task extremely complicate.</p>

<p><mark>Implicit Parallelism</mark>:</p>
<p>Allows programmers to write their programs without any concern about the exploitation of parallelism. Exploitation of parallelism is instead automatically performed by the compiler and/or the runtime system. In this way the parallelism is transparent to the programmer maintaining the complexity of software development at the same level of standard sequential programming.</p>
<p>Extracting parallelism implicitly is not an easy task. For imperative programming languages, the complexity of the problem is almost prohibitively and allows positive results only for restricted sets of applications (e.g., applications which perform intensive operations on arrays.</p>
<p>Declarative Programming languages, and in particular Functional and Logic languages, are characterized by a very high level of abstraction, allowing the programmer to focus on what the problem is and leaving implicit many details of how the problem should be solved.</p>
<p>Declarative languages have opened new doors to automatic exploitation of parallelism. Their focusing on a high level description of the problem and their mathematical nature turned into positive properties for implicit exploitation of parallelism.</p>

<p><mark>Methods for parallelism</mark>:</p>
<p>There are many methods of programming parallel computers. Two of the most common are message passing and data parallel.</p>
<p>1.Message Passing - the user makes calls to libraries to explicitly share information between processors.</p>
<p>2.Data Parallel - data partitioning determines parallelism</p>
<p>3.Shared Memory - multiple processes sharing common memory space</p>
<p>4.Remote Memory Operation - set of processes in which a process can access the memory of another process without its participation</p>
<p>5.Threads - a single process having multiple (concurrent) execution paths</p>
<p>6.Combined Models - composed of two or more of the above.</p>
		
		<p>for reference-
	</p>
						<a href="https://en.wikipedia.org/wiki/Parallel_programming_model" class="design-name" target="_blank">Parallel Programming Paradigm</a>
		
		                                                               <li>
						<a href="https://en.wikipedia.org/wiki/Concurrent_computing" class="design-name" target="_blank">Concurrent Programming Paradigm</a>
					</li>			
		<li>
						<a href="https://en.wikipedia.org/wiki/Functional_programming" class="design-name" target="_blank">Functional Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Logic_programming" class="design-name" target="_blank">Logic Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Dependent_type" class="design-name" target="_blank">Dependent Programming Paradigm</a>
					</li>					<li>
						<a href="https://www.inf.usi.ch/faculty/soule/teaching/2015-fall/netpl/lecture01-introduction.pdf" class="design-name" target="_blank">Network Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Symbolic_programming" class="design-name" target="_blank">Symbolic Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Automata-based_programming" class="design-name" target="_blank">Automata</a>
					</li>					<li>
						<a href="https://arpitonline.com/2010/06/12/rethinking-gu-programming-paradigms/" class="design-name" target="_blank">GUI</a>
					</li>					
							</ul>
				</nav>
			</div>

	</body>
</html>
