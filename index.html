<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>RA1811028010037</title>
	</head>

	<body style="background-color:papayawhip;">
	<style>
		 body{ 
	font: 75% georgia, sans-serif;
	line-height: 1.88889;
	color: #555753; 
	background: #fff url(http://csszengarden.com/001/blossoms.jpg) no-repeat bottom right; 
	margin: 0; 
	padding: 0;
	}
p { 
	margin-top: 0; 
	text-align: justify;
	}
h3 { 
	font: italic normal 1.4em georgia, sans-serif;
	letter-spacing: 1px; 
	margin-bottom: 0; 
	color: #7D775C;
	}
a:link { 
	font-weight: bold; 
	text-decoration: none; 
	color: #B7A5DF;
	}
a:visited { 
	font-weight: bold; 
	text-decoration: none; 
	color: #D4CDDC;
	}
a:hover, a:focus, a:active { 
	text-decoration: underline; 
	color: #9685BA;
	}
	</style>

	<div>
		<img src="image.png" alt="HTML Letters" width="1400" height="218" /> 
	</div>

		<div>
<h3>BY - NANDINI CHOURASIA(RA1811028010037)</h3>
		</div>
		<div>
<h2>PYTHON </h2>
<p>Python is an interpreted, high-level, general-purpose programming language. Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. Python is often described as a "batteries included" language due to its comprehensive standard library.reference-</p>
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python programming wiki</a>

<h1 style="text-align:center;">PROGRAMMING PARADIGMS </h1>
<p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.

Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p>
<a href="https://en.wikipedia.org/wiki/Programming_paradigm">Programming Paradigms wiki</a>
		</div>
	<div>
		<h4>15 <mark>Types</mark> of paradigm:
		</h4>
	</div>
	<div>
<ul>
	                                                  <li>
	                                                       <h4> Structured programming </h4>
						</li>
	<p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.
		It emerged in the late 1950s with the appearance of the ALGOL 58 and ALGOL 60 programming languages,with the latter including support for block structures.</p>
	<p>Structured programming is most frequently used with <mark>deviations</mark> that allow for clearer programs-</p>
	<p>1.Exceptional Handling.</p>
	<p>2.Early Exit.</p>
	<p>3.Multiple Entry.</p>
	<p>4.State Machines.</p>
	<p>
	
The <mark>languages</mark> that support Structured programming approach are:</p>

<p>C,C++,Java,C#,etc.</p>
<p> <mark>ADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH   are:</p>
<p>1.Easier to read and understand</p>
<p>2.User Friendly</p>
<p>3.Easier to Maintain</p>
<p>4.Mainly problem based instead of being machine based</p>
<p>5.Development is easier as it requires less effort and time</p>
<p>6.Easier to Debug</p>
<p>7.Machine-Independent, mostly.</p>
<p> <mark>DISADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH  are:</p>
<p>Since it is Machine-Independent, So it takes time to convert into machine code.</p>
<p>The converted machine code is not the same as for assembly language.</p>
<p>The program depends upon changeable factors like data-types. Therefore it needs to be updated with the need on the go.</p>
<p>Usually the development in this approach takes longer time as it is language-dependent. Whereas in the case of assembly language, the development takes lesser time as it is fixed for the machine.</p>
		<p>for reference-
		</p>
	<a href="https://en.wikipedia.org/wiki/Structured_programming" class="design-name" target="_blank">Structural Programming Paradigm</a> 
                                                                    <li>
									    <h4> Procedural Programming </h4>	
							</li>
	<p>Procedural programming is a programming paradigm, derived from structured programming,[citation needed] based on the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself.</p>
	<p>Computer processors provide hardware support for procedural programming through a stack register and instructions for calling procedures and returning from them. Hardware support for other types of programming is possible, but no attempt was commercially successful (for example Lisp machines or Java processors).</p>
	<p>Some important <mark>FEATURES</mark> are:</p>
	<p>1.Global Variable</p>
	<p>2.Local Variable</p>
	<p>3.Pre-Defined Functions</p>
	<p>4.Parameter Passing</p>
	<p> <mark>ADVANTAGES</mark> OF PROCEDURAL PROGRAMMING   are:</p>
<p>1.Procedural Programming is excellent for general-purpose programming</p>
<p>2.The coded simplicity along with ease of implementation of compilers and interpreters</p>
<p>3.A large variety of books and online course material available on tested algorithms, making it easier to learn along the way</p>
<p>4.The source code is portable, therefore, it can be used to target a different CPU as well</p>
<p>5.The code can be reused in different parts of the program, without the need to copy it.</p>
	<p>6.Through Procedural Programming technique, the memory requirement also slashes</p>
<p>7.The program flow can be tracked easily</p>
	<p> <mark>DISADVANTAGES</mark> OF PROCEDURAL PROGRAMMING</p>
<p>1.The program code is harder to write when Procedural Programming is employed</p>
<p>2.The Procedural code is often not reusable, which may pose the need to recreate the code if is needed to use in another application</p>
<p>3.Difficult to relate with real-world objects</p>
<p>4.The importance is given to the operation rather than the data, which might pose issues in some data-sensitive cases</p>
<p>5.The data is exposed to the whole program, making it not so much security friendly</p>
		<p>for reference-
	</p>          									
						<a href="https://en.wikipedia.org/wiki/Procedural_programming" class="design-name" target="_blank">Procedural Programming Paradigm</a>
										<li>
											<h4> Object Oriented Programming </h4>
					</li>
<p>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields known as attributes or properties, and code, in the form of procedures known as methods</p>
<p>Object-oriented <mark>languages</mark> include Java, C++, C#, Python, PHP, JavaScript, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Common Lisp, MATLAB, and Smalltalk.</p>
<p><mark>Objects and classes </mark>
<p>Languages that support object-oriented programming (OOP) typically use inheritance for code reuse and extensibility in the form of either classes or prototypes. Those that use classes support two main concepts:</p>

<p>Classes – the definitions for the data format and available procedures for a given type or class of object; may also contain data and procedures (known as class methods) themselves, i.e. classes contain the data members and member functions</p>
<p>Objects – instances of classes.Objects sometimes correspond to things found in the real world.</p>
<p>Objects are accessed somewhat like variables with complex internal structure, and in many languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. They provide a layer of abstraction which can be used to separate internal from external code. External code can use an object by calling a specific instance method with a certain set of input parameters, read an instance variable, or write to an instance variable. Objects are created by calling a special type of method in the class known as a<mark> constructor</mark>. A program may create many instances of the same class as it runs, which operate independently. This is an easy way for the same procedures to be used on different sets of data.
</p>	
	<p><mark>KEY FEATURES OF OBJECT ORIENTED PROGRAMMING</mark></p>
	<p><mark>1.ENCAPSULATION</mark>: In normal terms, Encapsulation is defined as wrapping up of data and information under a single unit. In Object-Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.</p>
	<p><mark>2.POLYMORPHISM</mark>: The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.</p>
	<p><mark>3.INHERITANCE</mark>: The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object-Oriented Programming.</p>

<p>1.Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.</p>
<p>2.Super Class:The class whose properties are inherited by sub class is called Base Class or Super class.</p>
<p>3.Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.</p>
	<p>for reference-
	</p>          

	<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" class="design-name" target="_blank">Object Oriented Programming Paradigm</a>					<li>
	<h4>Event Driven Programming Paradigm</p>
					</li>
<p>In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).</p>

<p>In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.</p>
	<p>Most existing <mark>GUI development tools and architectures</mark> rely on event-driven programming.The Java AWT framework processes all UI changes on a single thread, called the Event dispatching thread. </p>
	<p>Features include</p>
	<p><mark>Event Handlers</mark>:</p>
	<p>The first step in developing an event-driven program is to write a series of subroutines, or methods, called event-handler routines. These routines handle the events to which the main program will respond. For example, a single left-button mouse-click on a command button in a GUI program may trigger a routine that will open another window, save data to a database or exit the application. Many modern-day programming environments provide the programmer with event templates, allowing the programmer to focus on writing the event code.</p>

<p>The second step is to bind event handlers to events so that the correct function is called when the event takes place. Graphical editors combine the first two steps: double-click on a button, and the editor creates an (empty) event handler associated with the user clicking the button and opens a text window so you can edit the event handler.</p>

<p>The third step in developing an event-driven program is to write the main loop. This is a function that checks for the occurrence of events, and then calls the matching event handler to process it. Most event-driven programming environments already provide this main loop, so it need not be specifically provided by the application programmer. RPG, an early programming language from IBM, whose 1960s design concept was similar to event-driven programming discussed above, provided a built-in main I/O loop (known as the "program cycle") where the calculations responded in accordance to 'indicators' (flags) that were set earlier in the cycle.</p>
	<p><mark>Exception Handlers</mark>:In PL/I, even though a program itself may not be predominantly event-driven, certain abnormal events such as a hardware error, overflow or "program checks" may occur that possibly prevent further processing. Exception handlers may be provided by "ON statements" in (unseen) callers to provide cleaning routines to clean up afterwards before termination, or to perform recovery operations and return to the interrupted procedure.</p>
	<p>for reference-
	</p>
	<a href="https://en.wikipedia.org/wiki/Event-driven_programming" class="design-name" target="_blank">Event Driven Programming Paradigm</a> <li>
						<a href="https://en.wikipedia.org/wiki/Declarative_programming" class="design-name">Declarative Programming Paradigm</a> 
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Imperative_programming" class="design-name" target="_blank">Imperative Programming Paradigm</a> 
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Parallel_programming_model" class="design-name" target="_blank">Parallel Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Concurrent_computing" class="design-name" target="_blank">Concurrent Programming Paradigm</a>
					</li>			
		<li>
						<a href="https://en.wikipedia.org/wiki/Functional_programming" class="design-name" target="_blank">Functional Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Logic_programming" class="design-name" target="_blank">Logic Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Dependent_type" class="design-name" target="_blank">Dependent Programming Paradigm</a>
					</li>					<li>
						<a href="https://www.inf.usi.ch/faculty/soule/teaching/2015-fall/netpl/lecture01-introduction.pdf" class="design-name" target="_blank">Network Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Symbolic_programming" class="design-name" target="_blank">Symbolic Programming Paradigm</a>
					</li>					<li>
						<a href="https://en.wikipedia.org/wiki/Automata-based_programming" class="design-name" target="_blank">Automata</a>
					</li>					<li>
						<a href="https://arpitonline.com/2010/06/12/rethinking-gu-programming-paradigms/" class="design-name" target="_blank">GUI</a>
					</li>					
							</ul>
				</nav>
			</div>

	</body>
</html>
