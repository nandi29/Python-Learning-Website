<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>RA1811028010037</title>
	</head>

	<body style="background-color:papayawhip;">
	<style>
		 body{ 
	font: 75% georgia, sans-serif;
	line-height: 1.88889;
	color: #555753; 
	background: #fff url(http://csszengarden.com/001/blossoms.jpg) no-repeat bottom right; 
	margin: 0; 
	padding: 0;
	}
p { 
	margin-top: 0; 
	text-align: justify;
	}
h3 { 
	font: italic normal 1.4em georgia, sans-serif;
	letter-spacing: 1px; 
	margin-bottom: 0; 
	color: #7D775C;
	}
a:link { 
	font-weight: bold; 
	text-decoration: none; 
	color: #B7A5DF;
	}
a:visited { 
	font-weight: bold; 
	text-decoration: none; 
	color: #D4CDDC;
	}
a:hover, a:focus, a:active { 
	text-decoration: underline; 
	color: #9685BA;
	}
	</style>

	<div>
		<img src="image.png" alt="HTML Letters" width="1400" height="218" /> 
	</div>

		<div>
<h3>BY - NANDINI CHOURASIA(RA1811028010037)</h3>
		</div>
		<div>
<h2>PYTHON </h2>
<p>Python is an interpreted, high-level, general-purpose programming language. Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.Python is dynamically typed and garbage-collected. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. Python is often described as a "batteries included" language due to its comprehensive standard library.reference-</p>
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python programming wiki</a>

<h1 style="text-align:center;">PROGRAMMING PARADIGMS </h1>
<p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.

Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p>
<a href="https://en.wikipedia.org/wiki/Programming_paradigm">Programming Paradigms wiki</a>
		</div>
	<div>
		<h4>15 <mark>Types</mark> of paradigm:
		</h4>
	</div>
	<div>
<ul>
	                                                  <li>
	                                                       <h4> Structured programming </h4>
						</li>
	<p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.
		It emerged in the late 1950s with the appearance of the ALGOL 58 and ALGOL 60 programming languages,with the latter including support for block structures.</p>
	<p>Structured programming is most frequently used with <mark>deviations</mark> that allow for clearer programs-</p>
	<u1 style="list-style-type:circle;">
		<li>Exceptional Handling.</li>
		<li>Early Exit.</li>
		<li>Multiple Entry.</li>
		<li>State Machines.</li>
	</u1>
	<p>
	
The <mark>languages</mark> that support Structured programming approach are:</p>

<p>C,C++,Java,C#,etc.</p>
<p> <mark>ADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH   are:</p>
<u1 style="list-style-type:circle;">
	<li>Easier to read and understand</li>
	<li>User Friendly</li>
	<li>Easier to Maintain</li>
	<li>Mainly problem based instead of being machine based</li>
	<li>Development is easier as it requires less effort and time</li>
	<li>Easier to Debug</li>
	<li>Machine-Independent, mostly.</li>
</u1>
<p> <mark>DISADVANTAGES</mark> OF STRUCTURED PROGRAMMING APPROACH  are:</p>
<p>Since it is Machine-Independent, So it takes time to convert into machine code.</p>
<p>The converted machine code is not the same as for assembly language.</p>
<p>The program depends upon changeable factors like data-types. Therefore it needs to be updated with the need on the go.</p>
<p>Usually the development in this approach takes longer time as it is language-dependent. Whereas in the case of assembly language, the development takes lesser time as it is fixed for the machine.</p>
		<p>for reference-
		</p>
	<a href="https://en.wikipedia.org/wiki/Structured_programming" class="design-name" target="_blank">Structural Programming Paradigm</a> 
                                                                    <li>
									    <h4> Procedural Programming </h4>	
							</li>
	<p>Procedural programming is a programming paradigm, derived from structured programming,[citation needed] based on the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself.</p>
	<p>Computer processors provide hardware support for procedural programming through a stack register and instructions for calling procedures and returning from them. Hardware support for other types of programming is possible, but no attempt was commercially successful (for example Lisp machines or Java processors).</p>
	<p>Some important <mark>FEATURES</mark> are:</p>
	<u1 style="list-style-type:circle;">
		<li>Global Variable</li>
		<li>Local Variable</li>
		<li>Pre-Defined Functions</li>
		<li>Parameter Passing</li>
	</u1>
	<p> <mark>ADVANTAGES</mark> OF PROCEDURAL PROGRAMMING   are:</p>
<p>1.Procedural Programming is excellent for general-purpose programming</p>
<p>2.The coded simplicity along with ease of implementation of compilers and interpreters</p>
<p>3.A large variety of books and online course material available on tested algorithms, making it easier to learn along the way</p>
<p>4.The source code is portable, therefore, it can be used to target a different CPU as well</p>
<p>5.The code can be reused in different parts of the program, without the need to copy it.</p>
	<p>6.Through Procedural Programming technique, the memory requirement also slashes</p>
<p>7.The program flow can be tracked easily</p>
	<p> <mark>DISADVANTAGES</mark> OF PROCEDURAL PROGRAMMING</p>
<p>1.The program code is harder to write when Procedural Programming is employed</p>
<p>2.The Procedural code is often not reusable, which may pose the need to recreate the code if is needed to use in another application</p>
<p>3.Difficult to relate with real-world objects</p>
<p>4.The importance is given to the operation rather than the data, which might pose issues in some data-sensitive cases</p>
<p>5.The data is exposed to the whole program, making it not so much security friendly</p>
		<p>for reference-
	</p>          									
						<a href="https://en.wikipedia.org/wiki/Procedural_programming" class="design-name" target="_blank">Procedural Programming Paradigm</a>
										<li>
											<h4> Object Oriented Programming </h4>
					</li>
<p>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields known as attributes or properties, and code, in the form of procedures known as methods</p>
<p>Object-oriented <mark>languages</mark> include Java, C++, C#, Python, PHP, JavaScript, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Common Lisp, MATLAB, and Smalltalk.</p>
<p><mark>Objects and classes </mark>
<p>Languages that support object-oriented programming (OOP) typically use inheritance for code reuse and extensibility in the form of either classes or prototypes. Those that use classes support two main concepts:</p>

<p>Classes – the definitions for the data format and available procedures for a given type or class of object; may also contain data and procedures (known as class methods) themselves, i.e. classes contain the data members and member functions</p>
<p>Objects – instances of classes.Objects sometimes correspond to things found in the real world.</p>
<p>Objects are accessed somewhat like variables with complex internal structure, and in many languages are effectively pointers, serving as actual references to a single instance of said object in memory within a heap or stack. They provide a layer of abstraction which can be used to separate internal from external code. External code can use an object by calling a specific instance method with a certain set of input parameters, read an instance variable, or write to an instance variable. Objects are created by calling a special type of method in the class known as a<mark> constructor</mark>. A program may create many instances of the same class as it runs, which operate independently. This is an easy way for the same procedures to be used on different sets of data.
</p>	
	<p><mark>KEY FEATURES OF OBJECT ORIENTED PROGRAMMING</mark></p>
	<u1 style="list-style-type:circle;">
		<li><mark>1.ENCAPSULATION</mark>: In normal terms, Encapsulation is defined as wrapping up of data and information under a single unit. In Object-Oriented Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.</li>
		<li><mark>2.POLYMORPHISM</mark>: The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.</li>
		<li><mark>3.INHERITANCE</mark>: The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance is one of the most important features of Object-Oriented Programming.</li>
	</u1>

<p>1.Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.</p>
<p>2.Super Class:The class whose properties are inherited by sub class is called Base Class or Super class.</p>
<p>3.Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.</p>
	<p>for reference-
	</p>          

	<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" class="design-name" target="_blank">Object Oriented Programming Paradigm</a>					<li>
	<h4>Event Driven Programming Paradigm</p>
					</li>
<p>In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).</p>

<p>In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.</p>
	<p>Most existing <mark>GUI development tools and architectures</mark> rely on event-driven programming.The Java AWT framework processes all UI changes on a single thread, called the Event dispatching thread. </p>
	<p>Features include</p>
	<p><mark>Event Handlers</mark>:</p>
	<u1 style="list-style-type:circle;">
		<li>The first step in developing an event-driven program is to write a series of subroutines, or methods, called event-handler routines. These routines handle the events to which the main program will respond. For example, a single left-button mouse-click on a command button in a GUI program may trigger a routine that will open another window, save data to a database or exit the application. Many modern-day programming environments provide the programmer with event templates, allowing the programmer to focus on writing the event code.</li>
		<li>The second step is to bind event handlers to events so that the correct function is called when the event takes place. Graphical editors combine the first two steps: double-click on a button, and the editor creates an (empty) event handler associated with the user clicking the button and opens a text window so you can edit the event handler.</li>
		<li>The third step in developing an event-driven program is to write the main loop. This is a function that checks for the occurrence of events, and then calls the matching event handler to process it. Most event-driven programming environments already provide this main loop, so it need not be specifically provided by the application programmer. RPG, an early programming language from IBM, whose 1960s design concept was similar to event-driven programming discussed above, provided a built-in main I/O loop (known as the "program cycle") where the calculations responded in accordance to 'indicators' (flags) that were set earlier in the cycle.</li>
	</u1>
	<p><mark>Exception Handlers</mark>:In PL/I, even though a program itself may not be predominantly event-driven, certain abnormal events such as a hardware error, overflow or "program checks" may occur that possibly prevent further processing. Exception handlers may be provided by "ON statements" in (unseen) callers to provide cleaning routines to clean up afterwards before termination, or to perform recovery operations and return to the interrupted procedure.</p>
	<p>for reference-
	</p>
	<a href="https://en.wikipedia.org/wiki/Event-driven_programming" class="design-name" target="_blank">Event Driven Programming Paradigm</a> 
	    <li>
		<h4>Declarative Programming Paradigm</h4>				
					</li>	
<p>Declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.</p>
<p>Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives(the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.</p>
<p>Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.</p>
<p>Common <mark>Declarative languages include</mark> those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.</p>
<p>Some important points:</p>
	<u1 style="list-style-type:circle;">
		<li>Declarative programming is a programming paradigm that <mark>expresses the logic of a computation without describing its control flow.</li>
			<li>This paradigm often considers programs as theories of a formal logic, and computations as deductions in that logic space.</li>
		<li>Declarative programming is often defined as any style of programming that is not imperative.</li>
		<li>Common declarative languages include those of <mark>database query languages (SQL)</mark>, <mark>logic programming</mark>, <mark>functional programming</mark>, etc.</li>
		<li>A program that describes what computation should be performed and not how to compute it. Non-imperative, non-procedural.
Any programming language that lacks side effects(example: a function might modify a global variable or static variable, modify one of its arguments, raise an exception,etc).</li>
		<li>A language with a clear correspondence to mathematical logic.</li>
	</u1>
<p>Declarative Programming Paradigm:</p>
<p>A program that describes what computation should be performed and not how to compute it .</p>
<p>Any programming language that lacks side effects (or more specifically, is referentially transparent).</p>
<p>A language with a clear correspondence to mathematical logic</p>
<p>Here, the term side effect was mentioned.</p>
<p>A function or expression is said to have a side effect if, in addition to returning a value, it also modifies some state or has an observable interaction with calling functions or the outside world. For example, a function might modify a global variable or static variable, modify one of its arguments, raise an exception, write data to a display or file, read data, etc.</p>
<p>Examples of declarative languages are HTML, XML, CSS, JSON and SQL, and there are more</p>

<p><mark>SQL Elements</mark>:</p>
<p>SQL is the standard language used to communicate with a relational database.</p>
<p>It can be used to retrieve data from a database using a query but it can also be used to create, manage, destroy as well as modify their structure and contents.</p>

<p>The language is subdivided into several language elements, including:</p>
	<u1 style="list-style-type:circle;">
		<li>Clauses</li>
		<li>Expressions</li>
		<li>Predicates</li>
		<li>Queries</li>
		<li>Statements</li>
	</u1>
	<p>for reference-
	</p>
	
	<a href="https://en.wikipedia.org/wiki/Declarative_programming" class="design-name">Declarative Programming Paradigm</a> 
	                                                                       <li>
						 <h4>Imperative Programming Paradigm</h4>
					</li>
<p>The imperative programming paradigm assumes that the computer can maintain through environments of variables any changes in a computation process. Computations are performed through a guided sequence of steps, in which these variables are referred to or changed. The order of the steps is crucial, because a given step will have different consequences depending on the current values of variables when the step is executed.</p>
<p><mark>Imperative Languages</mark>:<p>
<p>Popular programming languages are imperative more often than they are any other paradigm studies in this course. There are two reasons for such popularity:</p>

<p>1.the imperative paradigm most closely resembles the actual machine itself, so the programmer is much closer to the machine</p>
<p>2.because of such closeness, the imperative paradigm was the only one efficient enough for widespread use until recently</p>

<p><mark>Advantages</mark>:</p>
	<u1 style="list-style-type:circle;">
		<li>efficient</li>
		<li>close to the machine</li>
		<li>popular</li>
		<li>familiar</li>
	</u1>
<p><mark>Disadvantages</mark>:</p>
	<u1 style="list-style-type:circle;">
		<li>The semantics of a program can be complex to understand or prove, because of referential transparency does not hold(due to side effects)</li>
		<li>Side effects also make debugging harder</li>
		<li>Abstration is more limitted than with some paradigms</li>
		<li>Order is crucial, which doesn't always suit itself to problems.</li>
	</u1>
	<p>for reference-
	</p>	
	<a href="https://en.wikipedia.org/wiki/Imperative_programming" class="design-name" target="_blank">Imperative Programming Paradigm</a>
	                                                                       <li>
										    <h4>Parallel Programming Paradigm</h4>   
					</li>
<p>Parallel programming model is an abstraction of parallel computer architecture, with which it is convenient to express algorithms and their composition in programs. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently the compiled programs can execute.The implementation of a parallel programming model can take the form of a library invoked from a sequential language, as an extension to an existing language, or as an entirely new language.</p>
<p>Consensus around a particular programming model is important because it leads to different parallel computers being built with support for the model, thereby facilitating portability of software. In this sense, programming models are referred to as bridging between hardware and software.</p>

<p>A system is said to be parallel if it can support two or more actions executing simultaneously i.e., <mark>multiple actions are simultaneously executed in parallel systems</mark>.</p>
<p>The evolution of parallel processing, even if slow, gave rise to a considerable variety of programming paradigms.</p>
<mark>Parallelism Types:</mark>
<p>1.Explicit Parallelism</p>
<p>2.Implicit Parallelism</p>

<p><mark>Explicit parallelism</mark>:</p>
<p>Explicit Parallelism is characterized by the presence of explicit constructs in the programming language, aimed at describing (to a certain degree of detail) the way in which the parallel computation will take place.</p>
<p>A wide range of solutions exists within this framework. One extreme is represented by the ``ancient'' use of basic, low level mechanisms to deal with parallelism--like fork/join primitives, semaphores, etc--eventually added to existing programming languages. Although this allows the highest degree of flexibility (any form of parallel control can be implemented in terms of the basic low level primitives gif), it leaves the additional layer of complexity completely on the shoulders of the programmer, making his task extremely complicate.</p>

<p><mark>Implicit Parallelism</mark>:</p>
<p>Allows programmers to write their programs without any concern about the exploitation of parallelism. Exploitation of parallelism is instead automatically performed by the compiler and/or the runtime system. In this way the parallelism is transparent to the programmer maintaining the complexity of software development at the same level of standard sequential programming.</p>
<p>Extracting parallelism implicitly is not an easy task. For imperative programming languages, the complexity of the problem is almost prohibitively and allows positive results only for restricted sets of applications (e.g., applications which perform intensive operations on arrays.</p>
<p>Declarative Programming languages, and in particular Functional and Logic languages, are characterized by a very high level of abstraction, allowing the programmer to focus on what the problem is and leaving implicit many details of how the problem should be solved.</p>
<p>Declarative languages have opened new doors to automatic exploitation of parallelism. Their focusing on a high level description of the problem and their mathematical nature turned into positive properties for implicit exploitation of parallelism.</p>

<p><mark>Methods for parallelism</mark>:</p>
<p>There are many methods of programming parallel computers. Two of the most common are message passing and data parallel.</p>
<p>1.Message Passing - the user makes calls to libraries to explicitly share information between processors.</p>
<p>2.Data Parallel - data partitioning determines parallelism</p>
<p>3.Shared Memory - multiple processes sharing common memory space</p>
<p>4.Remote Memory Operation - set of processes in which a process can access the memory of another process without its participation</p>
<p>5.Threads - a single process having multiple (concurrent) execution paths</p>
<p>6.Combined Models - composed of two or more of the above.</p>
		
		<p>for reference-
	</p>
						<a href="https://en.wikipedia.org/wiki/Parallel_programming_model" class="design-name" target="_blank">Parallel Programming Paradigm</a>
		
		                                                               <li>
						<h4>Concurrent Programming Paradigm</h4>
					</li>
		<p><mark>Concurrent computing</mark> is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.</p>
<p>This is a property of a system—whether a program, computer, or a network—where there is a separate execution point or "thread of control" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete.</p>
<p>Concurrent computing is a form of modular programming. In its paradigm an overall computation is factored into subcomputations that may be executed concurrently.
Concurrent computations may be executed in parallel,for example, by assigning each process to a separate processor or processor core, or distributing a computation across a network. In general, however, the languages, tools, and techniques for parallel programming might not be suitable for concurrent programming, and vice versa</p>
<p>Some important points:</p>
<p>Computing systems model the world, and the world contains actors that execute independently of, but communicate with, each other. In modelling the world, many (possibly) parallel executions have to be composed and coordinated, and that's where the study of concurrency comes in.</p>
<p>There are <mark>two common models for concurrent programming</mark>: shared memory and message passing.</p>
<p>1.<mark>Shared memory</mark>: In the shared memory model of concurrency, concurrent modules interact by reading and writing shared objects in memory.</p>
<p>2.<mark>Message passing</mark>: In the message-passing model, concurrent modules interact by sending messages to each other through a communication channel. Modules send off messages, and incoming messages to each module are queued up for handling.</p>

<p>Issues Concurrent Programming Paradigm :-</p>

<p>Concurrent programming is programming with multiple tasks. The major issues of concurrent programming are:</p>
<p>1.Sharing computational resources between the tasks</p>
<p>2.Interaction of the tasks.</p>

<p>Objects shared by multiple tasks have to be safe for concurrent access. Such objects are called protected. Tasks accessing such an object interact with each other indirectly through the object.
An access to the protected object can be:</p>
<p>Lock-free, when the task accessing the object is not blocked for a considerable time</p>
<p>Blocking, otherwise.</p>

<p><mark>Blocking objects can be used for task synchronization</mark>. To the examples of such objects belong:</p>
	<u1 style="list-style-type:circle;">
		<li>Events</li>
		<li>Mutexes and semaphores</li>
		<li>Waitable timers</li>
		<li>Queues</li>
	</u1>
<p><mark>Synchronization</mark> in Python :-</p>
	<u1 style="list-style-type:circle;">
		<li><mark>Locks</mark>:Locks are perhaps the simplest synchronization primitives in Python.A Lock has only two states — locked and unlocked (surprise). It is created in the unlocked state and has two principal methods — acquire() and release().The acquire() method locks the Lock and blocks execution until the release() method in some other co-routine sets it to unlocked.</li>
		<li></mark>R-Locks</mark>:R-Lock class is a version of simple locking that only blocks if the lock is held by another thread. While simple locks will block if the same thread attempts to acquire the same lock twice, a re-entrant lock only blocks if another thread currently holds the lock.</li>
		<li><mark>Semaphore</mark>:A semaphore has an internal counter rather than a lock flag, and it only blocks if more than a given number of threads have attempted to hold the semaphore. Depending on how the semaphore is initialized, this allows multiple threads to access the same code section simultaneously.</li>
	</u1>
<p>for reference-
	</p>
		<a href="https://en.wikipedia.org/wiki/Concurrent_computing" class="design-name" target="_blank">Concurrent Programming Paradigm</a>
		<li>
						<h4>Functional Programming Paradigm</h4>
					</li>	
<p><mark>Functional programming</mark> is a programming paradigm in which we try to bind everything in pure mathematical functions style. It is a declarative type of programming style. Its main focus is on “what to solve” in contrast to an imperative style where the main focus is “how to solve”. It uses expressions instead of statements. An expression is evaluated to produce a value whereas a statement is executed to assign variables.</p>
<p><mark>Functional Languages</mark>:</p>

<p>Functional languages are created based on the functional paradigm. Such languages permit functional solutions to problems by permitting a programmer to treat functions as first-class objects(they can be treated as data, assumed to have the value of what they return; therefore, they can be passed to other functions as arguments or returned from functions).</p>

<p>Often <mark>functional programs</mark> are:</p>
	<u1 style="list-style-type:circle;">
		<li>Easier to read.</li>
		<li>Easier to debug and maintain.</li>
		<li>Easier to parallelize.</li>
	</u1>
<p><mark>Useful features</mark>:
	<u1 style="list-style-type:circle;">
		<li>Hindley–Milner type system.</li>
		<li>Lazy evaluation.</li>
		<li>Closures.</li>
	</u1>
<p>All computations are implemented through functions: functions are first-class citizens.</p>
<p><mark>Main building blocks</mark>:</p>
	<u1 style="list-style-type:circle;">
		<li>Immutability: no variables gets changed (no side effects). In some sense, there are no variables.</li>
		<li>Recursions.</li>
		<li>Curried functions.</li>
		<li>Higher-order functions: compositions ('operators in functional analysis).</li>
	</u1>

<p><mark>Advantages</mark>:</p>
<p>The following are desirable properties of a functional language:</p>
	<u1 style="list-style-type:circle;">
		<li>The high level of abstraction, especially when functions are used, supresses many of the details of programming and thus removes the possibility of commiting many classes of errors</li>
		<li>The lack of dependence on assignment operations, allowing programs to be evaluated in many different orders. This evaluation order independence makes function-oriented languages good candidates for programming massively parallel computers</li>
		<li>The absence of assignment operations makes the function-oriented programs much more amenable to mathematical proof and analysis than are imperative programs, because functional programs possess referential transparency.</li>
	</u1>
<p> </p>
<p><mark>Disadvantages</mark>:</p>
<p>1.Perhaps less efficiencey</p>
<p>2.Problems involving many variables or a lot of sequential activity are sometimes easier to handle imperatively or with object-oriented programming.</p>
<p>for reference-
	</p>
<a href="https://en.wikipedia.org/wiki/Functional_programming" class="design-name" target="_blank">Functional Programming Paradigm</a>
                                                                               <li>
						<h4>Logic Programming Paradigm</h4>
					</li>	
<p>The <mark>Logical Paradigm</mark> takes a declarative approach to problem-solving. Various logical assertions about a situation are made, establishing all known facts. Then queries are made. The role of the computer becomes maintaining data and logical deduction.</p>
<p>Logical Paradigm Programming</p>
<p>A logical program is divided into three sections:</p>
<ul style="list-style-type:circle;">
  <li>a series of definitions/declarations that define the problem domain</li>
  <li>statements of relevant facts</li>
  <li>statement of goals in the form of a query</li>
</ul>
<p>Any deducible solution to a query is returned. The definitions and declarations are constructed entirely from relations. i.e. X is a member of Y or X is in the internal between a and b etc.</p>

<p><mark>Advantages</mark>:</p>
<p>The advantages of logic oriented programming are bifold:</p>
<ul style="list-style-type:circle;">
	<li>The system solves the problem, so the programming steps themselves are kept to a minimum</li>
	<li>Proving the validity of a given program is simple.</li>
</ul>
<p><mark>Disadvantages</mark>:</p>
<u1 style="list-style-type:circle;">
	<li>Perhaps less efficiencey</li>
	<li>Problems involving many variables or a lot of sequential activity are sometimes easier to handle imperatively or with object-oriented programming.</li>
</u1></p>
<p>for reference-
	</p>
<a href="https://en.wikipedia.org/wiki/Logic_programming" class="design-name" target="_blank">Logic Programming Paradigm</a>
                                                                                <li>
						<h4>Dependent Programming Paradigm</h4>
					</li>				
<p>In computer science and logic, a dependent type is a type whose definition <mark>depends on a value</mark>. It is an overlapping feature of type theory and type systems. In intuitionistic type theory, dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda, ATS, Coq, F*, Epigram, and Idris, dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.</p>
<p>Two common examples of <mark>dependent types</mark> are: dependent functions and dependent pairs.</p> 
<p>The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer where the array length is part of the type of the array. A dependent pair may have a second value of which the type depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.</p>
<p>Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence type checking may become undecidable.</p>

<p>A <mark>constant problem</mark>:</p>
<u1 style="list-style-type:circle;">
	<li>Writing a correct computer program is hard and proving that a program is correct is even harder</li>
	<li>Dependent Types allow us to write programs and know they are correct before running them.</li>
	<li>dependent types: you can specify types that can check the value of your variables at compile time</li>
</u1>
<p>In computer science and logic, a dependent type is a type whose definition depends on a value.</p>
<p>It is an overlapping feature of type theory and type systems.</p>
<p>Used to encode logic's quantifiers like "for all" and "there exists".</p>
<p>Dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.</p>
<p>for reference-
	</p>
<a href="https://en.wikipedia.org/wiki/Dependent_type" class="design-name" target="_blank">Dependent Programming Paradigm</a>
                                                                                 <li>
						<h4>Network Programming Paradigm</h4>
					</li>				
<p>A programming language provides abstractions and ways to compose those abstractions.The programming languages you are familiar with are models of computer systems.They provide abstractions for data and computation.</p>
<p>The <mark>Network paradigm involves thinking of computing in terms of a client</mark>, who is essentially in need of some type of information, and a server, who has lots of information and is just waiting to hand it out. Typically, a client will connect to a server and query for certain information. The server will go off and find the information and then return it to the client.
In the context of the Internet, clients are typically run on desktop or laptop computers attached to the Internet looking for information, whereas servers are typically run on larger computers with certain types of information available for the clients to retrieve. The Web itself is made up of a bunch of computers that act as Web servers; they have vast amounts of HTML pages and related data available for people to retrieve and browse. Web clients are used by those of us who connect to the Web servers and browse through the Web pages.</p>
<p>Network programming uses a particular type of network communication known as <mark>sockets</mark>. A socket is a software abstraction for an input or output medium of communication.</p>
<p><mark>Socket</mark>:</p>
<u1 style="list-style-type:circle;">
	<li>A socket is a software abstraction for an input or output medium of communication.</li>
	<li>Sockets allow communication between processes that lie on the same machine, or on different machines working in diverse environment and even across different continents.</li>
	<li>A socket is the most vital and fundamental entity. Sockets are the end-point of a two-way communication link.</li>
	<li>An endpoint is a combination of IP address and the port number.</li>
</u1>
<p><mark>For Client-Server communication</mark></p>
<u1 style="list-style-type:circle;">
	<li>Sockets are to be configured at the two ends to initiate a connection</li>
	<li>Listen for incoming messages</li>
	<li>Send the responses at both ends</li>
	<li>Establishing a bidirectional communication.</li>
</u1>
<p><mark>Socket Types</mark></p>
<u1 style="list-style-type:circle;">
	<li>Datagram Socket:
A datagram is an independent, self-contained piece of information sent over a network whose arrival, arrival time, and content are not guaranteed. A datagram socket uses User Datagram Protocol (UDP) to facilitate the sending of datagrams (self-contained pieces of information) in an unreliable manner. Unreliable means that information sent via datagrams isn't guaranteed to make it to its destination.</li>
	<li>Stream Socket:
A stream socket, or connected socket, is a socket through which data can be transmitted continuously. A stream socket is more akin to a live network, in which the communication link is continuously active. A stream socket is a "connected" socket through which data is transferred continuously.</li>
</u1>
</p>
<p>for reference-
	</p>
<a href="https://www.inf.usi.ch/faculty/soule/teaching/2015-fall/netpl/lecture01-introduction.pdf" class="design-name" target="_blank">Network Programming Paradigm</a>
                                                                                <li>
						<h4>Symbolic Programming Paradigm</h4>
					</li>				
<p><mark>Symbolic programming</mark> is a programming paradigm in which the program can manipulate its own formulas and program components as if they were plain data.</p>
<p>Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to "learn", which makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.</p>
<p>Languages that support symbolic programming include homoiconic languages such as Wolfram Language,LISP and Prolog.</p>
<p>Symbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.</p>
<p>It Covers the following:</p>
<u1 style="list-style-type:circle;">
	<li>As a calculator and symbols</li>
	<li>Algebraic Manipulations - Expand and Simplify</li>
	<li>Calculus – Limits, Differentiation, Series , Integration</li>
	<li>Equation Solving – Matrices</li>
</u1></p>
<p>for reference-
	</p>
<a href="https://en.wikipedia.org/wiki/Symbolic_programming" class="design-name" target="_blank">Symbolic Programming Paradigm</a>
                                                                                <li>
						<a href="https://en.wikipedia.org/wiki/Automata-based_programming" class="design-name" target="_blank">Automata</a>
					</li>					<li>
						<a href="https://arpitonline.com/2010/06/12/rethinking-gu-programming-paradigms/" class="design-name" target="_blank">GUI</a>
					</li>					
							</ul>
				</nav>
			</div>

	</body>
</html>
